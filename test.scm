
(define (list->string-h l str pos)
  (if (null? l)
      str
      (begin
        (string-set! str pos (car l))
        (list->string-h (cdr l) str (+ pos 1)))))
(define (list->string l)
  (let ((str (make-string (length l)))) (list->string-h l str 0)))
(define (string-h str chars pos)
  (if (null? chars)
      str
      (begin
        (string-set! str pos (car chars))
        (string-h str (cdr chars) (+ pos 1)))))
(define (string . chars)
  (if (null? chars)
      ""
      (let ((str (make-string (length chars)))) (string-h str chars 0))))
(define (substring-h to from posf post end)
  (if (= posf end)
      to
      (begin
        (string-set! to post (string-ref from posf))
        (substring-h to from (+ posf 1) (+ post 1) end))))
(define (substring string start end)
  (if (or (< start 0) (> end (string-length string)) (< end start))
      (error "Substring")
      (let ((new-str (make-string (- end start))))
        (substring-h new-str string start 0 end))))
(define (string-append-two str str2)
  (list->string (append (string->list str) (string->list str2))))
(define (string-append-h strings)
  (cond ((null? strings) "")
        ((null? (cdr strings)) (car strings))
        (else
         (string-append-h
          (cons (string-append-two (car strings) (cadr strings))
                (cddr strings))))))
(define (string-append . strings) (string-append-h strings))
(define (string-copy str) (list->string (string->list str)))
(define (string=?-h str1 str2 pos)
  (cond ((= pos (string-length str1)) (= pos (string-length str2)))
        ((= pos (string-length str2)) #f)
        (else
         (if (char=? (string-ref str1 pos) (string-ref str2 pos))
             (string=?-h str1 str2 (+ pos 1))
             #f))))
(define (string=? str1 str2) (string=?-h str1 str2 0))
(define (string<? str1 str2)
  (define (string<?-h str1 str2 pos)
    (cond ((= pos (- (string-length str2) 1))
           (char<? (string-ref str1 pos) (string-ref str2 pos)))
          ((= pos (- (string-length str1) 1))
           (char<=? (string-ref str1 pos) (string-ref str2 pos)))
          (else
           (and (char<=? (string-ref str1 pos) (string-ref str2 pos))
                (string<?-h str1 str2 (+ pos 1))))))
  (cond ((= (string-length str1) 0) (> (string-length str2) 0))
        ((= (string-length str2) 0) #f)
        (else (string<?-h str1 str2 0))))
(define (print n) (gambit$$print n))
(define (println . n) (gambit$$println n))
(define (pp n) (gambit$$pp n))
(define write (lambda (n) (pp n)))
(define (newline) (gambit$$newline))
(define (vector-fill! v el)
  (let loop ((l (- (vector-length v) 1)))
    (if (= l -1) v (begin (vector-set! v l el) (loop (- l 1))))))
(define FLOATvector-const vector)
(define FLOATvector-length vector-length)
(define FLOATvector-ref vector-ref)
(define (port? p) (or (input-port? p) (output-port? p)))
(define (boolean? n) (or (eq? n #t) (eq? n #f)))
(define (vector->list v) (vector->list-h v 0 (vector-length v)))
(define (vector->list-h vector idx length)
  (if (= idx length)
      '()
      (cons (vector-ref vector idx) (vector->list-h vector (+ idx 1) length))))
(define (list->vector l)
  (let ((v (make-vector (length l)))) (list->vector-h l v 0 (length l))))
(define (list->vector-h lst vec pos len)
  (if (null? lst)
      vec
      (begin
        (vector-set! vec pos (car lst))
        (list->vector-h (cdr lst) vec (+ pos 1) len))))
(define (number->string num)
  (define (digit->string d) (make-string 1 (integer->char (+ d 48))))
  (define (number->string-h num)
    (if (= num 0)
        ""
        (string-append
         (number->string-h (quotient num 10))
         (digit->string (modulo num 10)))))
  (cond ((= num 0) "0")
        ((< num 0) (string-append "-" (number->string-h (* num -1))))
        (else (number->string-h num))))
(define (string->number str . l)
  (define (s->n str pos)
    (if (= pos (string-length str))
        ""
        (let ((c (string-ref str pos)))
          (if (char-numeric? c)
              (let ((r (s->n str (+ pos 1))))
                (if r (string-append (make-string 1 c) r) #f))
              #f))))
  (if (= (string-length str) 0) #f (s->n str 0)))
(define (char<? c1 c2) (< (char->integer c1) (char->integer c2)))
(define (char>? c1 c2) (> (char->integer c1) (char->integer c2)))
(define (char<=? c1 c2) (<= (char->integer c1) (char->integer c2)))
(define (char>=? c1 c2) (>= (char->integer c1) (char->integer c2)))
(define (char-alphabetic? c)
  (let ((c (char->integer c)))
    (or (and (> c 64) (< c 91)) (and (> c 96) (< c 123)))))
(define (char-numeric? c)
  (let ((c (char->integer c))) (and (> c 47) (< c 58))))
(define (char-whitespace? c)
  (let ((c (char->integer c)))
    (or (= c 32) (= c 9) (= c 10) (= c 12) (= c 13))))
(define (char-upper-case? c)
  (let ((c (char->integer c))) (and (> c 64) (< c 91))))
(define (char-lower-case? c)
  (let ((c (char->integer c))) (and (> c 96) (< c 123))))
(define (char-upcase c)
  (let ((v (char->integer c)))
    (if (and (> v 96) (< v 123)) (integer->char (- v 32)) c)))
(define (char-downcase c)
  (let ((v (char->integer c)))
    (if (and (> v 64) (< v 91)) (integer->char (+ v 32)) c)))
(define (char-ci=? c1 c2)
  (= (char->integer (char-downcase c1)) (char->integer (char-downcase c2))))
(define (char-ci<? c1 c2)
  (< (char->integer (char-downcase c1)) (char->integer (char-downcase c2))))
(define (char-ci>? c1 c2)
  (> (char->integer (char-downcase c1)) (char->integer (char-downcase c2))))
(define (char-ci<=? c1 c2)
  (<= (char->integer (char-downcase c1)) (char->integer (char-downcase c2))))
(define (char-ci>=? c1 c2)
  (>= (char->integer (char-downcase c1)) (char->integer (char-downcase c2))))
(define (length l)
  (let loop ((l l) (len 0))
    (cond ((null? l) len)
          ((pair? l) (loop (cdr l) (+ 1 len)))
          (else (error "LIST expected")))))
(define (##append-two lst1 lst2)
  (if (null? lst1) lst2 (cons (car lst1) (##append-two (cdr lst1) lst2))))
(define (append . lsts)
  (let loop ((lsts lsts))
    (if (null? lsts) '() (##append-two (car lsts) (loop (cdr lsts))))))
(define (list? n) (or (null? n) (and (pair? n) (list? (cdr n)))))
(define (list-ref lst i) (if (= i 0) (car lst) (list-ref (cdr lst) (- i 1))))
(define (reverse l)
  (let loop ((l l) (r '()))
    (cond ((null? l) r)
          ((pair? l) (loop (cdr l) (cons (car l) r)))
          (else (error "LIST expected")))))
(define (for-each f lst)
  (if (not (null? lst)) (begin (f (car lst)) (for-each f (cdr lst)))))
(define (assq el lst)
  (cond ((null? lst) #f)
        ((eq? el (car (car lst))) (car lst))
        (else (assq el (cdr lst)))))
(define (assv el lst)
  (cond ((null? lst) #f)
        ((eqv? el (car (car lst))) (car lst))
        (else (assv el (cdr lst)))))
(define (assoc el lst)
  (cond ((null? lst) #f)
        ((equal? el (car (car lst))) (car lst))
        (else (assoc el (cdr lst)))))
(define (memq el lst)
  (cond ((null? lst) #f) ((eq? el (car lst)) lst) (else (memq el (cdr lst)))))
(define (memv el lst)
  (cond ((null? lst) #f) ((eqv? el (car lst)) lst) (else (memv el (cdr lst)))))
(define (member el lst)
  (cond ((null? lst) #f)
        ((equal? el (car lst)) lst)
        (else (member el (cdr lst)))))
(define (map fn lst)
  (if (null? lst) '() (cons (fn (car lst)) (map fn (cdr lst)))))
(define (error msg . msgs)
  (define (print-msgs msgs)
    (if (null? msgs)
        (newline)
        (begin (print (car msgs)) (print " ") (print-msgs (cdr msgs)))))
  (print "!!! ERROR - ")
  (print-msgs (cons msg msgs))
  (exit))
(define fatal-error (lambda (msg . msgs) (apply error (cons msg msgs))))
(define (apply fn args . r)
  (define (gen-args l)
    (if (= (length l) 1)
        (if (list? (car l)) (car l) (error "APPLY ERROR"))
        (cons (car l) (gen-args (cdr l)))))
  (let ((args (if (null? r) args (gen-args (cons args r)))))
    (if (not (list? args)) (error "LIST EXPECTED"))
    (##apply fn args)))
(define (integer? n) (fixnum? n))
(define (positive? x) (> x 0))
(define (negative? x) (< x 0))
(define (even? x) (= (modulo x 2) 0))
(define (odd? x) (= (modulo x 2) 1))
(define (expt n m) (if (= m 0) 1 (* n (expt n (- m 1)))))
(define (max a . l)
  (define (max-h els m)
    (if (null? els)
        m
        (let ((c (car els)))
          (if (> c m) (max-h (cdr els) c) (max-h (cdr els) m)))))
  (max-h l a))
(define (min a . l)
  (define (min-h els m)
    (if (null? els)
        m
        (let ((c (car els)))
          (if (< (car els) m)
              (min-h (cdr els) (car els))
              (min-h (cdr els) m)))))
  (min-h l a))
(define (exact? n) #t)
(define exact->inexact (lambda (x) x))
(define (call/cc . n)
  (let ((l (length n)))
    (cond ((= l 1) ((car n) #f))
          ((= l 2) ((car n) #f (cadr n)))
          (else (error "call/cc")))))
(define abs (lambda (x) (if (< x 0) (- x) x)))
(define (read) (gambit$$read))


(define sym 'TEST)


(println (symbol? 'kkk))


;; ->
;; * Merge regalloc
;; * Merge max versions
;; * add bound tests


;; NEXT:
;; * check cc-key
;; * utiliser un systeme pour les globales non mutables compatible avec le nouvel cst vers.
;; * return value (type cr)

;; TODO: quand on récupère l'emplacement d'une variable, regarder les slots pour trouver la meilleure loc (cst > reg > mem)
;; TODO: #<ctx-tclo #3 sym: closure mem-allocated?: #t is-cst: (lambda () ($$atom 1)) cst: #f fn-num: 0>
;;       pourquoi l'ast dans is-cst?
;; TODO: merge de regalloc
;; TODO: merge de version
;; TODO: jitter le alloc-rt pour ne pas générer de code si la taille ne nécessite pas un still
;; TODO: ajouter le support des constantes dans les globales non mutables

;; Liveness: terminer le travail
;; Letrec: attention aux lates !function
;; Liveness: pb sur '() ?
;; Liveness: cas spécial, set-box! est un kill
;; Liveness: alpha conversion
;; Regalloc: pb movs en trop (fib.s)

;; TODO: optimization: pour un pt entrée:
;;       * si on génère un pt entrée dont la 1ere instruction est un jump,
;;       * on peut patcher le pt d'entrée pour sauter directement au bon endroit
